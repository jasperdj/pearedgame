<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block World - Peared Demo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-database-compat.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e; 
            color: #eee;
            overflow: hidden;
        }
        
        /* Game Canvas */
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        /* Game UI Overlay */
        #game-ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
        }
        #player-list {
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            min-width: 150px;
        }
        #player-list h3 {
            margin-bottom: 8px;
            font-size: 12px;
            text-transform: uppercase;
            color: #888;
        }
        .player-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .player-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 8px;
        }
        .player-name {
            flex: 1;
        }
        .player-host {
            font-size: 10px;
            background: #4CAF50;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 5px;
        }
        
        /* Connection Button */
        #connect-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            z-index: 100;
        }
        #connect-btn:hover { background: #45a049; }
        #connect-btn.hosting { background: #2196F3; }
        #connect-btn.connected { background: #666; }
        
        /* Connection Status */
        #connection-status {
            position: absolute;
            top: 60px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 100;
        }
        
        /* Instructions */
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
        }
        
        /*=============================================
          PEARED POPUP STYLES
        =============================================*/
        .peared-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .peared-overlay.active { display: flex; }
        
        .peared-popup {
            background: #2d2d44;
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }
        
        .peared-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .peared-header h2 {
            font-size: 20px;
            color: #fff;
        }
        .peared-close {
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .peared-close:hover { color: #fff; }
        
        .peared-tabs {
            display: flex;
            border-bottom: 2px solid #444;
            margin-bottom: 20px;
        }
        .peared-tab {
            padding: 10px 20px;
            cursor: pointer;
            color: #888;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: all 0.2s;
        }
        .peared-tab:hover { color: #ccc; }
        .peared-tab.active {
            color: #4CAF50;
            border-bottom-color: #4CAF50;
        }
        
        .peared-content { display: none; }
        .peared-content.active { display: block; }
        
        .peared-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            width: 100%;
            margin-bottom: 10px;
        }
        .peared-btn:hover { background: #45a049; }
        .peared-btn:disabled { background: #555; cursor: not-allowed; }
        .peared-btn.secondary { background: #555; }
        .peared-btn.secondary:hover { background: #666; }
        
        .peared-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #444;
            border-radius: 6px;
            background: #1a1a2e;
            color: #fff;
            font-size: 14px;
            margin-bottom: 10px;
        }
        .peared-input:focus { outline: none; border-color: #4CAF50; }
        
        .peared-status {
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 14px;
        }
        .peared-status.info { background: rgba(33,150,243,0.2); color: #64B5F6; }
        .peared-status.success { background: rgba(76,175,80,0.2); color: #81C784; }
        .peared-status.warning { background: rgba(255,193,7,0.2); color: #FFD54F; }
        .peared-status.error { background: rgba(244,67,54,0.2); color: #E57373; }
        
        .peared-qr {
            text-align: center;
            margin: 20px 0;
            background: white;
            padding: 20px;
            border-radius: 8px;
            display: inline-block;
        }
        .peared-qr-container {
            text-align: center;
        }
        
        .peared-video-container {
            position: relative;
            width: 100%;
            max-width: 300px;
            margin: 0 auto;
            border-radius: 8px;
            overflow: hidden;
        }
        .peared-video {
            width: 100%;
            display: block;
        }
        
        .peared-manual-input {
            width: 100%;
            height: 80px;
            resize: none;
        }
        
        .peared-divider {
            text-align: center;
            margin: 15px 0;
            color: #666;
            font-size: 12px;
        }
        
        .peared-player-setup {
            margin-bottom: 20px;
        }
        .peared-player-setup label {
            display: block;
            margin-bottom: 5px;
            color: #888;
            font-size: 12px;
        }
        
        .peared-pending-list {
            margin: 15px 0;
        }
        .peared-pending-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a2e;
            padding: 10px;
            border-radius: 6px;
            margin: 5px 0;
        }
        .peared-pending-item button {
            padding: 6px 12px;
            font-size: 12px;
            margin-left: 5px;
        }
        
        /* Debug Panel */
        .peared-debug-panel {
            display: none;
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 400px;
            max-height: 300px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid #444;
            border-radius: 8px;
            z-index: 2000;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 11px;
        }
        .peared-debug-panel.active { display: block; }
        
        .peared-debug-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #333;
            border-radius: 8px 8px 0 0;
            color: #4CAF50;
            font-weight: bold;
        }
        .peared-debug-close {
            background: none;
            border: none;
            color: #888;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .peared-debug-close:hover { color: #fff; }
        
        .peared-debug-log {
            height: 200px;
            overflow-y: auto;
            padding: 10px;
            color: #0f0;
        }
        .peared-debug-log .log-entry {
            margin: 2px 0;
            padding: 2px 0;
            border-bottom: 1px solid #222;
        }
        .peared-debug-log .log-time { color: #666; }
        .peared-debug-log .log-info { color: #64B5F6; }
        .peared-debug-log .log-success { color: #81C784; }
        .peared-debug-log .log-warning { color: #FFD54F; }
        .peared-debug-log .log-error { color: #E57373; }

        /* Room Browser Styles */
        .peared-room-code-input {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }
        .peared-room-code-input input {
            flex: 1;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 18px;
            text-align: center;
        }
        .peared-room-code-input button {
            padding: 12px 20px;
        }

        .peared-room-browser {
            max-height: 250px;
            overflow-y: auto;
            margin: 10px 0;
        }
        .peared-room-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a2e;
            padding: 12px 15px;
            border-radius: 8px;
            margin: 8px 0;
            cursor: pointer;
            transition: background 0.2s;
        }
        .peared-room-item:hover {
            background: #252540;
        }
        .peared-room-info {
            flex: 1;
        }
        .peared-room-host {
            font-weight: bold;
            color: #fff;
            margin-bottom: 3px;
        }
        .peared-room-meta {
            font-size: 12px;
            color: #888;
        }
        .peared-room-players {
            background: #333;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 10px;
        }
        .peared-room-players.full {
            background: #c0392b;
        }
        .peared-room-join-btn {
            padding: 8px 16px;
            font-size: 13px;
            margin-left: 10px;
        }

        .peared-no-rooms {
            text-align: center;
            color: #666;
            padding: 30px;
            font-size: 14px;
        }

        .peared-host-options {
            margin: 15px 0;
        }
        .peared-host-options label {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #aaa;
            font-size: 14px;
            cursor: pointer;
        }
        .peared-host-options input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }

        .peared-room-code-display {
            background: #1a1a2e;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            margin: 15px 0;
        }
        .peared-room-code-display .code {
            font-size: 32px;
            font-weight: bold;
            letter-spacing: 8px;
            color: #4CAF50;
            font-family: monospace;
        }
        .peared-room-code-display .label {
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
        }

        .peared-firebase-status {
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 4px;
            display: inline-block;
            margin-left: 10px;
        }
        .peared-firebase-status.connected {
            background: rgba(76, 175, 80, 0.2);
            color: #81C784;
        }
        .peared-firebase-status.disconnected {
            background: rgba(244, 67, 54, 0.2);
            color: #E57373;
        }

        .peared-divider-text {
            display: flex;
            align-items: center;
            text-align: center;
            color: #666;
            font-size: 12px;
            margin: 15px 0;
        }
        .peared-divider-text::before,
        .peared-divider-text::after {
            content: '';
            flex: 1;
            border-bottom: 1px solid #444;
        }
        .peared-divider-text span {
            padding: 0 10px;
        }

        .peared-refresh-btn {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            padding: 5px;
            font-size: 16px;
        }
        .peared-refresh-btn:hover {
            color: #fff;
        }
    </style>
</head>
<body>
    <!-- Game Container -->
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <!-- Game UI -->
        <div id="game-ui">
            <div id="player-list">
                <h3>Players</h3>
                <div id="players"></div>
            </div>
        </div>
        
        <button id="connect-btn">üéÆ Host or Join</button>
        <div id="connection-status">Not connected</div>
        <div id="instructions">Arrow keys or WASD to move</div>
    </div>
    
    <!-- Peared Connection Popup -->
    <div id="peared-overlay" class="peared-overlay">
        <div class="peared-popup">
            <div class="peared-header">
                <h2>üçê Peared Connection <span id="peared-firebase-status" class="peared-firebase-status disconnected">offline</span></h2>
                <button class="peared-close" id="peared-close">&times;</button>
            </div>
            
            <!-- Player Setup -->
            <div class="peared-player-setup">
                <label>Your Name</label>
                <input type="text" id="peared-player-name" class="peared-input" placeholder="Enter your name" maxlength="20">
            </div>
            
            <!-- Mode Selection Tabs -->
            <div class="peared-tabs">
                <div class="peared-tab active" data-tab="host">Host Game</div>
                <div class="peared-tab" data-tab="join">Join Game</div>
            </div>
            
            <!-- Host Game Content -->
            <div id="peared-host" class="peared-content active">
                <p style="color: #888; margin-bottom: 15px;">Start hosting and share your room code with others.</p>

                <div class="peared-host-options">
                    <label>
                        <input type="checkbox" id="peared-public-room" checked>
                        Public room (visible in browser)
                    </label>
                </div>

                <button id="peared-start-host" class="peared-btn">üéÆ Start Hosting</button>

                <div id="peared-host-active" style="display: none;">
                    <!-- Room Code Display -->
                    <div class="peared-room-code-display">
                        <div class="label">ROOM CODE</div>
                        <div class="code" id="peared-room-code">------</div>
                    </div>
                    <button id="peared-copy-room-code" class="peared-btn secondary">üìã Copy Room Code</button>

                    <div id="peared-connected-players" class="peared-pending-list" style="margin-top: 15px;">
                        <div class="peared-divider">‚Äî Connected Players ‚Äî</div>
                        <p id="peared-no-players" style="color: #666; font-size: 14px;">Waiting for players to join...</p>
                    </div>

                    <!-- Manual fallback (collapsed by default) -->
                    <details style="margin-top: 20px;">
                        <summary style="color: #666; cursor: pointer; font-size: 12px;">Advanced: Manual Code Exchange</summary>
                        <div style="margin-top: 10px;">
                            <div class="peared-status info">Share this with players without internet:</div>
                            <textarea id="peared-host-code" class="peared-input peared-manual-input" readonly style="font-size: 10px;"></textarea>
                            <button id="peared-copy-code" class="peared-btn secondary" style="font-size: 12px;">üìã Copy Full Code</button>

                            <div class="peared-divider" style="margin-top: 15px;">‚Äî Paste Player Response ‚Äî</div>
                            <textarea id="peared-answer-input" class="peared-input peared-manual-input" placeholder="Paste response here..." style="font-size: 10px;"></textarea>
                            <button id="peared-accept-player" class="peared-btn" style="font-size: 12px;">‚úì Accept</button>
                        </div>
                    </details>
                </div>
            </div>
            
            <!-- Join Game Content -->
            <div id="peared-join" class="peared-content">
                <!-- Room Code Input -->
                <div class="peared-room-code-input">
                    <input type="text" id="peared-room-code-input" class="peared-input" placeholder="ROOM CODE" maxlength="6">
                    <button id="peared-join-room-btn" class="peared-btn">Join</button>
                </div>

                <!-- Public Rooms Browser -->
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span style="color: #888; font-size: 12px; text-transform: uppercase;">Public Games</span>
                    <button id="peared-refresh-rooms" class="peared-refresh-btn" title="Refresh">üîÑ</button>
                </div>
                <div id="peared-room-browser" class="peared-room-browser">
                    <div class="peared-no-rooms">Looking for games...</div>
                </div>

                <!-- Joining Status -->
                <div id="peared-joining-status" style="display: none; margin-top: 15px;">
                    <div class="peared-status info">Connecting to room...</div>
                </div>

                <!-- Manual fallback -->
                <details style="margin-top: 20px;">
                    <summary style="color: #666; cursor: pointer; font-size: 12px;">Advanced: Manual Code Exchange</summary>
                    <div style="margin-top: 10px;">
                        <div class="peared-tabs" style="border-bottom: 1px solid #444;">
                            <div class="peared-tab active" data-subtab="paste">Paste Code</div>
                            <div class="peared-tab" data-subtab="scan">Scan QR</div>
                        </div>

                        <div id="peared-paste" class="peared-content active" style="margin-top: 15px;">
                            <textarea id="peared-join-code" class="peared-input peared-manual-input" placeholder="Paste the host's full code here..." style="font-size: 10px;"></textarea>
                            <button id="peared-connect" class="peared-btn" style="font-size: 12px;">üîó Connect</button>
                        </div>

                        <div id="peared-scan" class="peared-content" style="margin-top: 15px;">
                            <div class="peared-video-container">
                                <video id="peared-video" class="peared-video" playsinline></video>
                            </div>
                            <canvas id="peared-canvas" style="display: none;"></canvas>
                            <button id="peared-start-camera" class="peared-btn" style="margin-top: 10px; font-size: 12px;">üì∑ Start Camera</button>
                            <button id="peared-stop-camera" class="peared-btn secondary" style="display: none; font-size: 12px;">Stop Camera</button>
                        </div>

                        <div id="peared-join-answer" style="display: none; margin-top: 15px;">
                            <div class="peared-status warning">Send this response back to the host:</div>
                            <textarea id="peared-answer-code" class="peared-input peared-manual-input" readonly style="font-size: 10px;"></textarea>
                            <button id="peared-copy-answer" class="peared-btn secondary" style="font-size: 12px;">üìã Copy Response</button>
                        </div>
                    </div>
                </details>
            </div>
            
            <div id="peared-status" class="peared-status info" style="display: none;"></div>
            
            <!-- Debug Log Toggle -->
            <button id="peared-debug-toggle" class="peared-btn secondary" style="margin-top: 15px; font-size: 12px;">
                üîß Show Debug Log
            </button>
        </div>
    </div>
    
    <!-- Peared Debug Log Panel -->
    <div id="peared-debug-panel" class="peared-debug-panel">
        <div class="peared-debug-header">
            <span>üçê Peared Debug Log</span>
            <button id="peared-debug-close" class="peared-debug-close">&times;</button>
        </div>
        <div id="peared-debug-log" class="peared-debug-log"></div>
        <button id="peared-debug-clear" class="peared-btn secondary" style="margin: 10px; padding: 6px 12px; font-size: 12px;">Clear Log</button>
    </div>

<script>
/*=============================================
  FIREBASE SIGNALING
  =============================================
  Handles room creation, discovery, and WebRTC
  signaling via Firebase Realtime Database.
=============================================*/

const firebaseConfig = {
  apiKey: "AIzaSyAA5a1OAXyFuqtRG6sgtPi7NTQSOQbji18",
  authDomain: "peared-1e0a5.firebaseapp.com",
  databaseURL: "https://peared-1e0a5-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "peared-1e0a5",
  storageBucket: "peared-1e0a5.firebasestorage.app",
  messagingSenderId: "357774303231",
  appId: "1:357774303231:web:7f4ab22291ef7498ed91ca"
};

// Initialize Firebase
let firebaseApp = null;
let firebaseDb = null;
let firebaseConnected = false;

try {
  firebaseApp = firebase.initializeApp(firebaseConfig);
  firebaseDb = firebase.database();

  // Monitor connection state
  firebaseDb.ref('.info/connected').on('value', (snapshot) => {
    firebaseConnected = snapshot.val() === true;
    const statusEl = document.getElementById('peared-firebase-status');
    if (statusEl) {
      statusEl.textContent = firebaseConnected ? 'online' : 'offline';
      statusEl.className = 'peared-firebase-status ' + (firebaseConnected ? 'connected' : 'disconnected');
    }
  });
  console.log('[Firebase] Initialized successfully');
} catch (error) {
  console.error('[Firebase] Initialization failed:', error);
}

class FirebaseSignaling {
  constructor() {
    this.db = firebaseDb;
    this.currentRoom = null;
    this.roomRef = null;
    this.listeners = [];
  }

  // Generate a 6-character room code
  generateRoomCode() {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Removed confusing characters
    let code = '';
    for (let i = 0; i < 6; i++) {
      code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return code;
  }

  // Create a room (host) - legacy method
  async createRoom(hostName, isPublic = true) {
    return this.createRoomWithOffer(hostName, isPublic, null);
  }

  // Create a room with offer already included (prevents race condition)
  async createRoomWithOffer(hostName, isPublic = true, offer = null) {
    const roomCode = this.generateRoomCode();
    const roomData = {
      host: hostName,
      public: isPublic,
      created: firebase.database.ServerValue.TIMESTAMP,
      players: 1,
      maxPlayers: 6,
      offer: offer,  // Include offer immediately so clients can connect
      answer: null   // Client will write here
    };

    try {
      await this.db.ref(`rooms/${roomCode}`).set(roomData);
      this.currentRoom = roomCode;
      this.roomRef = this.db.ref(`rooms/${roomCode}`);

      // Set up cleanup on disconnect
      this.roomRef.onDisconnect().remove();

      console.log(`[Firebase] Room created: ${roomCode}`);
      return roomCode;
    } catch (error) {
      console.error('[Firebase] Failed to create room:', error);
      throw error;
    }
  }

  // Update room with WebRTC offer
  async setOffer(offer) {
    if (!this.roomRef) return;
    await this.roomRef.child('offer').set(offer);
    console.log('[Firebase] Offer set');
  }

  // Listen for answers (host)
  onAnswer(callback) {
    if (!this.roomRef) return;

    const answerRef = this.roomRef.child('answer');
    const listener = answerRef.on('value', (snapshot) => {
      const answer = snapshot.val();
      if (answer) {
        console.log('[Firebase] Answer received');
        callback(answer);
        // Clear the answer so next client can join
        answerRef.remove();
      }
    });

    this.listeners.push({ ref: answerRef, event: 'value', callback: listener });
  }

  // Get list of public rooms
  async getPublicRooms() {
    try {
      const snapshot = await this.db.ref('rooms')
        .orderByChild('public')
        .equalTo(true)
        .once('value');

      const rooms = [];
      snapshot.forEach((child) => {
        const room = child.val();
        // Only include rooms less than 10 minutes old
        const age = Date.now() - room.created;
        if (age < 10 * 60 * 1000) {
          rooms.push({
            code: child.key,
            ...room
          });
        }
      });

      return rooms;
    } catch (error) {
      console.error('[Firebase] Failed to get rooms:', error);
      return [];
    }
  }

  // Join a room (client)
  async joinRoom(roomCode) {
    const roomRef = this.db.ref(`rooms/${roomCode.toUpperCase()}`);

    try {
      const snapshot = await roomRef.once('value');
      if (!snapshot.exists()) {
        throw new Error('Room not found');
      }

      const room = snapshot.val();
      if (!room.offer) {
        throw new Error('Room not ready - host is still setting up');
      }

      this.currentRoom = roomCode.toUpperCase();
      this.roomRef = roomRef;

      console.log(`[Firebase] Joined room: ${roomCode}`);
      return room;
    } catch (error) {
      console.error('[Firebase] Failed to join room:', error);
      throw error;
    }
  }

  // Submit answer (client)
  async setAnswer(answer) {
    if (!this.roomRef) return;
    await this.roomRef.child('answer').set(answer);
    console.log('[Firebase] Answer submitted');
  }

  // Listen for offer updates (client - for reconnection)
  onOfferUpdate(callback) {
    if (!this.roomRef) return;

    const offerRef = this.roomRef.child('offer');
    const listener = offerRef.on('value', (snapshot) => {
      const offer = snapshot.val();
      if (offer) {
        callback(offer);
      }
    });

    this.listeners.push({ ref: offerRef, event: 'value', callback: listener });
  }

  // Update player count
  async updatePlayerCount(count) {
    if (!this.roomRef) return;
    await this.roomRef.child('players').set(count);
  }

  // Update heartbeat timestamp (for room expiration)
  async updateHeartbeat() {
    if (!this.roomRef) return;
    await this.roomRef.child('lastHeartbeat').set(firebase.database.ServerValue.TIMESTAMP);
  }

  // Subscribe to room list updates
  onRoomsUpdate(callback) {
    const roomsRef = this.db.ref('rooms');

    const listener = roomsRef.on('value', (snapshot) => {
      const rooms = [];
      const now = Date.now();
      snapshot.forEach((child) => {
        const room = child.val();
        if (room.public && room.offer) {
          // Check if room is still active (heartbeat within last 2 minutes, or created within last 2 minutes)
          const lastActive = room.lastHeartbeat || room.created;
          const timeSinceActive = now - lastActive;
          if (timeSinceActive < 2 * 60 * 1000) {
            rooms.push({
              code: child.key,
              ...room
            });
          }
        }
      });
      callback(rooms);
    });

    this.listeners.push({ ref: roomsRef, event: 'value', callback: listener });
  }

  // Cleanup
  destroy() {
    // Remove all listeners
    this.listeners.forEach(({ ref, event, callback }) => {
      ref.off(event, callback);
    });
    this.listeners = [];

    // Delete room if we're the host
    if (this.roomRef) {
      this.roomRef.remove();
    }

    this.currentRoom = null;
    this.roomRef = null;
  }
}

/*=============================================
  PEARED LIBRARY - P2P Gaming Framework
  =============================================
  A lightweight WebRTC library for peer-to-peer
  multiplayer games with a host/client model.

  API:
    const peared = new Peared(options);
    peared.host(playerName)     - Start hosting
    peared.join(playerName)     - Open join dialog
    peared.send(type, data)     - Send to host (client) or broadcast (host)
    peared.broadcast(type, data) - Send to all clients (host only)
    peared.sendTo(peerId, type, data) - Send to specific peer
    peared.getPlayers()         - Get all connected players
    peared.isHost               - Check if hosting
    peared.localPlayer          - Get local player info
    peared.close()              - Close all connections
    peared.showPopup()          - Show connection popup
    peared.hidePopup()          - Hide connection popup

  Options:
    onPlayerJoin(player)        - Called when a player joins
    onPlayerLeave(player)       - Called when a player leaves
    onMessage(from, type, data) - Called when a game message is received
    onStateChange(state, isHost)- Called when connection state changes
    getState()                  - [Host] Return current game state for new players
    onStateSync(state)          - [Client] Called with game state when joining

  Features:
    - Automatic state sync when players join
    - Session history (last 5 sessions saved to localStorage)
    - Quick resume from recent sessions
    - QR code and manual code connection methods
=============================================*/

class Peared {
    constructor(options = {}) {
        this.options = {
            onPlayerJoin: options.onPlayerJoin || (() => {}),
            onPlayerLeave: options.onPlayerLeave || (() => {}),
            onMessage: options.onMessage || (() => {}),
            onStateChange: options.onStateChange || (() => {}),
            // State sync callbacks - for syncing game state when players join
            getState: options.getState || null,      // () => gameState (host provides current state)
            onStateSync: options.onStateSync || (() => {}),  // (state) => void (clients receive state)
            iceServers: options.iceServers || [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { 
                    urls: ['turn:openrelay.metered.ca:80', 'turn:openrelay.metered.ca:443'],
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                }
            ]
        };
        
        this.isHost = false;
        this.localPlayer = null;
        this.peers = new Map(); // peerId -> { connection, dataChannel, player }
        this.pendingConnections = new Map(); // peerId -> { connection, offer }
        this.allPlayers = new Map(); // playerId -> player (all known players including self)
        this.state = 'disconnected'; // disconnected, hosting, connecting, connected

        // Firebase signaling
        this.firebase = new FirebaseSignaling();
        this.roomCode = null;
        this._heartbeatInterval = null;

        this._setupUI();
        this._setupDebugPanel();
        this._setupSessionHistory();
        this._setupFirebaseUI();
        this._setupCleanup();
        this._log('info', 'Peared initialized');
    }

    _setupCleanup() {
        // Clean up room when page is closed/refreshed
        window.addEventListener('beforeunload', () => {
            if (this.isHost && this.firebase.roomRef) {
                // Use sendBeacon for reliable cleanup on page unload
                // Firebase doesn't support sendBeacon, so we use onDisconnect (already set)
                // But also try synchronous remove as backup
                try {
                    this.firebase.roomRef.remove();
                } catch (e) {
                    // Ignore - onDisconnect will handle it
                }
            }
        });

        // Also clean up on visibility change (tab hidden for too long)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && this.isHost) {
                // Update last seen timestamp
                this.firebase.updateHeartbeat();
            }
        });
    }

    _startHeartbeat() {
        // Send heartbeat every 30 seconds to indicate room is still active
        if (this._heartbeatInterval) clearInterval(this._heartbeatInterval);
        this._heartbeatInterval = setInterval(() => {
            if (this.isHost && this.firebase.roomRef) {
                this.firebase.updateHeartbeat();
            }
        }, 30000);
    }

    _stopHeartbeat() {
        if (this._heartbeatInterval) {
            clearInterval(this._heartbeatInterval);
            this._heartbeatInterval = null;
        }
    }

    // ===== FIREBASE INTEGRATION =====

    _setupFirebaseUI() {
        // Room code copy button
        document.getElementById('peared-copy-room-code')?.addEventListener('click', () => {
            const code = this.roomCode;
            if (code) {
                navigator.clipboard.writeText(code).then(() => {
                    const btn = document.getElementById('peared-copy-room-code');
                    btn.textContent = '‚úì Copied!';
                    setTimeout(() => btn.textContent = 'üìã Copy Room Code', 2000);
                });
            }
        });

        // Join room by code
        document.getElementById('peared-join-room-btn')?.addEventListener('click', () => {
            const code = document.getElementById('peared-room-code-input').value.trim();
            if (code) {
                this._joinViaFirebase(code);
            }
        });

        // Room code input - auto uppercase and join on Enter
        document.getElementById('peared-room-code-input')?.addEventListener('input', (e) => {
            e.target.value = e.target.value.toUpperCase();
        });
        document.getElementById('peared-room-code-input')?.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('peared-join-room-btn').click();
            }
        });

        // Refresh rooms button
        document.getElementById('peared-refresh-rooms')?.addEventListener('click', () => {
            this._refreshRoomBrowser();
        });

        // Start listening for room updates
        if (firebaseConnected || firebaseDb) {
            this.firebase.onRoomsUpdate((rooms) => {
                this._renderRoomBrowser(rooms);
            });
        }
    }

    _renderRoomBrowser(rooms) {
        const container = document.getElementById('peared-room-browser');
        if (!container) return;

        if (rooms.length === 0) {
            container.innerHTML = '<div class="peared-no-rooms">No public games available</div>';
            return;
        }

        container.innerHTML = rooms.map(room => `
            <div class="peared-room-item" data-code="${room.code}">
                <div class="peared-room-info">
                    <div class="peared-room-host">${room.host}'s Game</div>
                    <div class="peared-room-meta">Code: ${room.code}</div>
                </div>
                <span class="peared-room-players ${room.players >= room.maxPlayers ? 'full' : ''}">
                    ${room.players}/${room.maxPlayers}
                </span>
                <button class="peared-btn peared-room-join-btn" ${room.players >= room.maxPlayers ? 'disabled' : ''}>
                    Join
                </button>
            </div>
        `).join('');

        // Add click handlers
        container.querySelectorAll('.peared-room-item').forEach(item => {
            const joinBtn = item.querySelector('.peared-room-join-btn');
            if (joinBtn && !joinBtn.disabled) {
                joinBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const code = item.dataset.code;
                    this._joinViaFirebase(code);
                });
            }
        });
    }

    async _refreshRoomBrowser() {
        const container = document.getElementById('peared-room-browser');
        if (container) {
            container.innerHTML = '<div class="peared-no-rooms">Looking for games...</div>';
        }
        const rooms = await this.firebase.getPublicRooms();
        this._renderRoomBrowser(rooms);
    }

    async _joinViaFirebase(roomCode) {
        const statusEl = document.getElementById('peared-joining-status');
        if (statusEl) {
            statusEl.style.display = 'block';
            statusEl.querySelector('.peared-status').textContent = `Connecting to ${roomCode}...`;
        }

        try {
            const room = await this.firebase.joinRoom(roomCode);
            this._log('info', `Joining room ${roomCode}, host: ${room.host}`);

            // Set up local player
            const playerName = document.getElementById('peared-player-name').value || 'Player';
            this.localPlayer = {
                id: this._generateId(),
                name: playerName,
                color: this._generateColor(),
                isHost: false
            };
            this.allPlayers.set(this.localPlayer.id, this.localPlayer);

            // Process the offer from Firebase
            const offerData = room.offer;
            this._log('info', `Processing offer from host "${offerData.hostName}"`);

            const answerData = await this._createClientAnswerFromOffer(offerData);

            // Submit answer via Firebase
            await this.firebase.setAnswer(answerData);

            if (statusEl) {
                statusEl.querySelector('.peared-status').textContent = 'Waiting for host to accept...';
            }

            // Save session
            this._saveSession('client', this.localPlayer.name, room.host);

        } catch (error) {
            this._log('error', 'Failed to join room', error.message);
            if (statusEl) {
                statusEl.querySelector('.peared-status').textContent = `Error: ${error.message}`;
                statusEl.querySelector('.peared-status').className = 'peared-status error';
            }
        }
    }

    async _createClientAnswerFromOffer(offerData) {
        this._log('info', `Connecting to host "${offerData.hostName}"`);

        const connection = new RTCPeerConnection({ iceServers: this.options.iceServers });

        // Handle incoming data channel
        connection.ondatachannel = (event) => {
            this._log('info', 'Data channel received from host');
            this._setupDataChannel(event.channel, offerData.hostId);
        };

        // ICE candidate gathering
        const candidates = [];
        connection.onicecandidate = (e) => {
            if (e.candidate) {
                candidates.push(e.candidate);
            }
        };

        // Connection state
        connection.onconnectionstatechange = () => {
            this._log('info', `Connection state: ${connection.connectionState}`);
            if (connection.connectionState === 'connected') {
                this.state = 'connected';
                this._updateState();
            } else if (connection.connectionState === 'disconnected' || connection.connectionState === 'failed') {
                this._log('warning', 'Connection lost');
                this.state = 'disconnected';
                this._updateState();
                this.options.onPlayerLeave({ id: offerData.hostId });
            }
        };

        this.peers.set(offerData.hostId, {
            connection,
            dataChannel: null,
            player: { id: offerData.hostId, name: offerData.hostName, isHost: true }
        });

        // Process offer
        await connection.setRemoteDescription(new RTCSessionDescription(offerData.offer));
        this._log('info', 'Remote description (offer) set');

        if (offerData.candidates) {
            for (const candidate of offerData.candidates) {
                await connection.addIceCandidate(new RTCIceCandidate(candidate));
            }
        }

        // Create answer
        const answer = await connection.createAnswer();
        await connection.setLocalDescription(answer);

        // Wait for ICE gathering
        await this._waitForIce(connection);

        // Convert RTCSessionDescription to plain object for Firebase serialization
        const answerSdp = connection.localDescription;
        return {
            peerId: offerData.peerId,
            answer: { type: answerSdp.type, sdp: answerSdp.sdp },
            player: this.localPlayer,
            candidates: candidates.map(c => c.toJSON ? c.toJSON() : c)
        };
    }

    // ===== SESSION HISTORY =====

    _getSessionHistory() {
        try {
            return JSON.parse(localStorage.getItem('peared_sessions') || '[]');
        } catch {
            return [];
        }
    }

    _saveSession(role, playerName, hostName = null) {
        const sessions = this._getSessionHistory();

        // Remove existing session with same name/role combo
        const filtered = sessions.filter(s =>
            !(s.role === role && s.playerName === playerName)
        );

        // Add new session at front
        filtered.unshift({
            id: this._generateId(),
            role,
            playerName,
            hostName,
            timestamp: Date.now()
        });

        // Keep only last 5
        const trimmed = filtered.slice(0, 5);
        localStorage.setItem('peared_sessions', JSON.stringify(trimmed));

        this._renderSessionHistory();
    }

    _setupSessionHistory() {
        // Create session history UI in popup
        const popup = document.querySelector('.peared-popup .peared-content.active');
        if (!popup) return;

        this._renderSessionHistory();
    }

    _renderSessionHistory() {
        const sessions = this._getSessionHistory();
        if (sessions.length === 0) return;

        // Check if container exists, create if not
        let container = document.getElementById('peared-session-history');
        if (!container) {
            container = document.createElement('div');
            container.id = 'peared-session-history';
            container.style.cssText = 'margin-top: 15px; border-top: 1px solid #444; padding-top: 15px;';

            // Insert before the tabs
            const tabs = document.querySelector('.peared-tabs');
            if (tabs) {
                tabs.parentNode.insertBefore(container, tabs);
            }
        }

        container.innerHTML = `
            <div style="color: #888; font-size: 11px; margin-bottom: 8px; text-transform: uppercase;">
                Recent Sessions
            </div>
            ${sessions.map(s => `
                <button class="peared-btn secondary peared-session-btn"
                        data-role="${s.role}"
                        data-name="${s.playerName}"
                        data-host="${s.hostName || ''}"
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                    <span>
                        <span style="color: ${s.role === 'host' ? '#4CAF50' : '#2196F3'};">
                            ${s.role === 'host' ? 'üëë' : 'üéÆ'}
                        </span>
                        ${s.playerName}
                        ${s.hostName ? `<span style="color: #666; font-size: 10px;">(‚Üí ${s.hostName})</span>` : ''}
                    </span>
                    <span style="color: #666; font-size: 10px;">
                        ${this._formatTimeAgo(s.timestamp)}
                    </span>
                </button>
            `).join('')}
        `;

        // Add click handlers
        container.querySelectorAll('.peared-session-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const role = btn.dataset.role;
                const name = btn.dataset.name;

                // Set the name
                document.getElementById('peared-player-name').value = name;

                // Switch to appropriate tab
                const tabs = document.querySelectorAll('.peared-tabs .peared-tab');
                tabs.forEach(tab => tab.classList.remove('active'));

                if (role === 'host') {
                    document.querySelector('[data-tab="host"]').classList.add('active');
                    document.getElementById('peared-host').classList.add('active');
                    document.getElementById('peared-join').classList.remove('active');
                    // Auto-start hosting
                    this._startHosting();
                } else {
                    document.querySelector('[data-tab="join"]').classList.add('active');
                    document.getElementById('peared-join').classList.add('active');
                    document.getElementById('peared-host').classList.remove('active');
                }
            });
        });
    }

    _formatTimeAgo(timestamp) {
        const seconds = Math.floor((Date.now() - timestamp) / 1000);
        if (seconds < 60) return 'just now';
        if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
        if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
        return `${Math.floor(seconds / 86400)}d ago`;
    }
    
    // ===== LOGGING =====
    
    _log(level, message, data = null) {
        const time = new Date().toLocaleTimeString('en-US', { hour12: false });
        const logEntry = { time, level, message, data };
        
        // Console log
        const consoleMsg = `[Peared ${time}] ${message}`;
        if (level === 'error') console.error(consoleMsg, data || '');
        else if (level === 'warning') console.warn(consoleMsg, data || '');
        else console.log(consoleMsg, data || '');
        
        // UI log
        const logContainer = document.getElementById('peared-debug-log');
        if (logContainer) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">${time}</span> <span class="log-${level}">${message}</span>`;
            if (data) {
                const dataStr = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
                if (dataStr.length < 100) {
                    entry.innerHTML += ` <span style="color:#888">${dataStr}</span>`;
                }
            }
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
    }
    
    _setupDebugPanel() {
        // Toggle button
        document.getElementById('peared-debug-toggle')?.addEventListener('click', () => {
            const panel = document.getElementById('peared-debug-panel');
            const isActive = panel.classList.toggle('active');
            document.getElementById('peared-debug-toggle').textContent = 
                isActive ? 'üîß Hide Debug Log' : 'üîß Show Debug Log';
        });
        
        // Close button
        document.getElementById('peared-debug-close')?.addEventListener('click', () => {
            document.getElementById('peared-debug-panel').classList.remove('active');
            document.getElementById('peared-debug-toggle').textContent = 'üîß Show Debug Log';
        });
        
        // Clear button
        document.getElementById('peared-debug-clear')?.addEventListener('click', () => {
            document.getElementById('peared-debug-log').innerHTML = '';
            this._log('info', 'Log cleared');
        });
    }
    
    // ===== PUBLIC API =====
    
    host(playerName) {
        this.isHost = true;
        this.localPlayer = {
            id: this._generateId(),
            name: playerName || 'Host',
            color: this._generateColor(),
            isHost: true
        };
        this.allPlayers.set(this.localPlayer.id, this.localPlayer);
        this.state = 'hosting';
        this._log('success', `Started hosting as "${this.localPlayer.name}"`, { playerId: this.localPlayer.id });
        this._updateState();
        this._saveSession('host', this.localPlayer.name);
        this.options.onPlayerJoin(this.localPlayer);
        return this.localPlayer;
    }
    
    getPlayers() {
        return Array.from(this.allPlayers.values());
    }
    
    send(type, data) {
        const message = JSON.stringify({ type, data, from: this.localPlayer?.id });
        console.log('[Peared] send - type:', type, 'from:', this.localPlayer?.id);

        if (this.isHost) {
            // Host broadcasts to all clients
            this.peers.forEach(peer => {
                if (peer.dataChannel?.readyState === 'open') {
                    peer.dataChannel.send(message);
                }
            });
        } else {
            // Client sends to host
            const hostPeer = this.peers.values().next().value;
            if (hostPeer?.dataChannel?.readyState === 'open') {
                hostPeer.dataChannel.send(message);
            }
        }
    }
    
    broadcast(type, data, excludeId = null, originalFrom = null) {
        if (!this.isHost) return;
        // Use originalFrom if provided (for relaying), otherwise use host's ID
        const senderId = originalFrom || this.localPlayer?.id;
        const message = JSON.stringify({ type, data, from: senderId });

        this.peers.forEach((peer, peerId) => {
            if (peerId !== excludeId && peer.dataChannel?.readyState === 'open') {
                peer.dataChannel.send(message);
            }
        });
    }
    
    sendTo(peerId, type, data) {
        const peer = this.peers.get(peerId);
        if (peer?.dataChannel?.readyState === 'open') {
            const message = JSON.stringify({ type, data, from: this.localPlayer?.id });
            peer.dataChannel.send(message);
        }
    }
    
    close() {
        this.peers.forEach(peer => {
            peer.dataChannel?.close();
            peer.connection?.close();
        });
        this.peers.clear();
        this.pendingConnections.clear();
        this.allPlayers.clear();
        this.state = 'disconnected';
        this.isHost = false;
        this.localPlayer = null;
        this.roomCode = null;

        // Stop heartbeat
        this._stopHeartbeat();

        // Clean up Firebase
        this.firebase.destroy();

        this._updateState();
    }
    
    showPopup() {
        document.getElementById('peared-overlay').classList.add('active');
        this._renderSessionHistory();
    }
    
    hidePopup() {
        document.getElementById('peared-overlay').classList.remove('active');
        this._stopCamera();
    }
    
    // ===== PRIVATE: CONNECTION MANAGEMENT =====
    
    async _createHostOffer() {
        const peerId = this._generateId();
        this._log('info', `Creating offer for new peer`, { peerId });
        
        const connection = new RTCPeerConnection({ iceServers: this.options.iceServers });
        
        const dataChannel = connection.createDataChannel('peared');
        this._setupDataChannel(dataChannel, peerId);
        
        this.pendingConnections.set(peerId, { connection, dataChannel });
        
        // ICE candidate gathering
        const candidates = [];
        connection.onicecandidate = (e) => {
            if (e.candidate) {
                candidates.push(e.candidate);
                this._log('info', `ICE candidate gathered`, { type: e.candidate.type || 'unknown' });
            }
        };
        
        const offer = await connection.createOffer();
        await connection.setLocalDescription(offer);
        this._log('info', 'Local description set, gathering ICE...');
        
        // Wait for ICE gathering
        await this._waitForIce(connection);
        this._log('success', `Offer ready with ${candidates.length} ICE candidates`);
        
        // Convert RTCSessionDescription to plain object for Firebase serialization
        const offerSdp = connection.localDescription;
        return {
            peerId,
            offer: { type: offerSdp.type, sdp: offerSdp.sdp },
            hostId: this.localPlayer.id,
            hostName: this.localPlayer.name,
            candidates: candidates.map(c => c.toJSON ? c.toJSON() : c)
        };
    }
    
    async _processAnswer(answerData) {
        this._log('info', `Processing answer from peer`, { peerId: answerData.peerId });
        
        const pending = this.pendingConnections.get(answerData.peerId);
        if (!pending) {
            this._log('error', 'No pending connection found', { peerId: answerData.peerId });
            return false;
        }
        
        try {
            await pending.connection.setRemoteDescription(new RTCSessionDescription(answerData.answer));
            this._log('info', 'Remote description set');
            
            if (answerData.candidates) {
                this._log('info', `Adding ${answerData.candidates.length} ICE candidates`);
                for (const candidate of answerData.candidates) {
                    await pending.connection.addIceCandidate(new RTCIceCandidate(candidate));
                }
            }
            
            // Move to active peers
            this.peers.set(answerData.peerId, pending);
            this.pendingConnections.delete(answerData.peerId);
            
            this._log('success', 'Peer connection established', { peerId: answerData.peerId });
            return true;
        } catch (error) {
            this._log('error', 'Error processing answer', error.message);
            return false;
        }
    }
    
    async _createClientAnswer(offerData) {
        this._log('info', `Connecting to host "${offerData.hostName}"`);
        
        const connection = new RTCPeerConnection({ iceServers: this.options.iceServers });
        
        this.localPlayer = {
            id: this._generateId(),
            name: document.getElementById('peared-player-name').value || 'Player',
            color: this._generateColor(),
            isHost: false
        };
        this.allPlayers.set(this.localPlayer.id, this.localPlayer);
        this._log('info', `Local player created: "${this.localPlayer.name}"`);
        
        // Handle incoming data channel
        connection.ondatachannel = (event) => {
            this._log('info', 'Data channel received from host');
            this._setupDataChannel(event.channel, offerData.hostId);
        };
        
        // ICE candidate gathering
        const candidates = [];
        connection.onicecandidate = (e) => {
            if (e.candidate) {
                candidates.push(e.candidate);
                this._log('info', `ICE candidate gathered`, { type: e.candidate.type || 'unknown' });
            }
        };
        
        // Connection state
        connection.onconnectionstatechange = () => {
            this._log('info', `Connection state: ${connection.connectionState}`);
            if (connection.connectionState === 'connected') {
                this.state = 'connected';
                this._updateState();
            } else if (connection.connectionState === 'disconnected' || connection.connectionState === 'failed') {
                this._log('warning', 'Connection lost');
                this.state = 'disconnected';
                this._updateState();
                this.options.onPlayerLeave({ id: offerData.hostId });
            }
        };
        
        this.peers.set(offerData.hostId, { 
            connection, 
            dataChannel: null,
            player: { id: offerData.hostId, name: offerData.hostName, isHost: true }
        });
        
        // Process offer
        await connection.setRemoteDescription(new RTCSessionDescription(offerData.offer));
        this._log('info', 'Remote description (offer) set');
        
        if (offerData.candidates) {
            this._log('info', `Adding ${offerData.candidates.length} host ICE candidates`);
            for (const candidate of offerData.candidates) {
                await connection.addIceCandidate(new RTCIceCandidate(candidate));
            }
        }
        
        // Create answer
        const answer = await connection.createAnswer();
        await connection.setLocalDescription(answer);
        this._log('info', 'Local description (answer) set, gathering ICE...');
        
        // Wait for ICE gathering
        await this._waitForIce(connection);
        this._log('success', `Answer ready with ${candidates.length} ICE candidates`);
        
        return {
            peerId: offerData.peerId,
            answer: connection.localDescription,
            player: this.localPlayer,
            candidates
        };
    }
    
    _setupDataChannel(dataChannel, peerId) {
        dataChannel.onopen = () => {
            this._log('success', `Data channel OPEN with peer`, { peerId });
            
            const peer = this.peers.get(peerId) || this.pendingConnections.get(peerId);
            if (peer) {
                peer.dataChannel = dataChannel;
                
                if (this.isHost) {
                    // Move from pending to active if needed
                    if (this.pendingConnections.has(peerId)) {
                        this.peers.set(peerId, peer);
                        this.pendingConnections.delete(peerId);
                    }
                    this._updateConnectedPlayersList();
                } else {
                    this.state = 'connected';
                    this._updateState();

                    // Get local state (position) if available
                    const localState = this.options.getState ? this.options.getState() : null;
                    const myState = localState ? localState[this.localPlayer.id] : null;

                    // Get host name from peer
                    const hostPeer = this.peers.values().next().value;
                    const hostName = hostPeer?.player?.name || 'Host';

                    // Save session to history
                    this._saveSession('client', this.localPlayer.name, hostName);

                    // Send our player info + initial state to host
                    this._log('info', 'Sending player info to host');
                    dataChannel.send(JSON.stringify({
                        type: '_peared_join',
                        data: {
                            player: this.localPlayer,
                            initialState: myState  // Include our position
                        }
                    }));
                }
            }
        };
        
        dataChannel.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);
                this._log('info', `Message received: ${message.type}`, { from: message.from });
                this._handleMessage(peerId, message);
            } catch (e) {
                this._log('error', 'Error parsing message', e.message);
            }
        };
        
        dataChannel.onclose = () => {
            this._log('warning', `Data channel CLOSED with peer`, { peerId });
            const peer = this.peers.get(peerId);
            if (peer?.player) {
                this.allPlayers.delete(peer.player.id);
                this.options.onPlayerLeave(peer.player);

                if (this.isHost) {
                    // Notify other clients
                    this.broadcast('_peared_leave', { playerId: peer.player.id }, peerId);
                    this._updateConnectedPlayersList();
                }
            }
            this.peers.delete(peerId);
        };
        
        dataChannel.onerror = (error) => {
            this._log('error', 'Data channel error', error);
        };
    }
    
    _handleMessage(fromPeerId, message) {
        const { type, data, from } = message;
        console.log('[Peared] _handleMessage - fromPeerId:', fromPeerId, 'type:', type, 'from (in msg):', from);

        // Internal Peared messages
        if (type === '_peared_join') {
            this._log('success', `Player joined: "${data.player.name}"`, { playerId: data.player.id });

            // Add to allPlayers map
            this.allPlayers.set(data.player.id, data.player);

            if (this.isHost) {
                // Host: store player info in peer entry
                const peer = this.peers.get(fromPeerId);
                if (peer) {
                    peer.player = data.player;
                }

                // Notify game about new player first
                this.options.onPlayerJoin(data.player);

                // Apply new player's initial state if provided
                if (data.initialState) {
                    this._log('info', 'Applying new player initial state', data.initialState);
                    this.options.onStateSync({
                        [data.player.id]: data.initialState
                    });
                }

                // Send current player list to new player
                this.sendTo(fromPeerId, '_peared_players', {
                    players: this.getPlayers()
                });

                // Notify other clients about new player FIRST (so they add the player)
                this.broadcast('_peared_join', { player: data.player }, fromPeerId);

                // THEN send full game state to everyone (so positions are correct)
                if (this.options.getState) {
                    const gameState = this.options.getState();
                    this._log('info', 'Sending state sync to all players');
                    // Send to new player
                    this.sendTo(fromPeerId, '_peared_state', { state: gameState });
                    // Broadcast to existing players so they get new player's position
                    this.broadcast('_peared_state', { state: gameState }, fromPeerId);
                }

                this._updateConnectedPlayersList();
            } else {
                // Client receiving broadcast about another player joining
                this.options.onPlayerJoin(data.player);
            }
            return;
        }
        
        if (type === '_peared_players') {
            // Client receiving full player list
            this._log('info', `Received player list (${data.players.length} players)`);
            data.players.forEach(player => {
                // Add all players to allPlayers map
                this.allPlayers.set(player.id, player);
                if (player.id !== this.localPlayer?.id) {
                    this.options.onPlayerJoin(player);
                }
            });
            return;
        }

        if (type === '_peared_state') {
            // Client receiving game state sync from host
            this._log('info', 'Received state sync from host');
            this.options.onStateSync(data.state);
            return;
        }
        
        if (type === '_peared_leave') {
            this.allPlayers.delete(data.playerId);
            this.options.onPlayerLeave({ id: data.playerId });
            return;
        }
        
        // Game messages - relay to other clients with original sender preserved
        if (this.isHost) {
            this.broadcast(type, data, fromPeerId, from);
        }

        this.options.onMessage(from, type, data);
    }
    
    async _waitForIce(connection, timeout = 5000) {
        if (connection.iceGatheringState === 'complete') return;
        
        return new Promise((resolve) => {
            const timer = setTimeout(resolve, timeout);
            
            const check = () => {
                if (connection.iceGatheringState === 'complete') {
                    clearTimeout(timer);
                    resolve();
                }
            };
            
            connection.addEventListener('icegatheringstatechange', check);
        });
    }
    
    // ===== PRIVATE: UI MANAGEMENT =====
    
    _setupUI() {
        // Tab switching
        document.querySelectorAll('.peared-tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                const tabId = e.target.dataset.tab || e.target.dataset.subtab;
                if (!tabId) return;
                
                const parent = e.target.parentElement;
                parent.querySelectorAll('.peared-tab').forEach(t => t.classList.remove('active'));
                e.target.classList.add('active');
                
                const isSubtab = e.target.dataset.subtab;
                const contents = isSubtab 
                    ? parent.parentElement.querySelectorAll(':scope > .peared-content')
                    : document.querySelectorAll('#peared-host, #peared-join');
                    
                contents.forEach(c => c.classList.remove('active'));
                document.getElementById(`peared-${tabId}`).classList.add('active');
            });
        });
        
        // Close popup
        document.getElementById('peared-close').addEventListener('click', () => this.hidePopup());
        document.getElementById('peared-overlay').addEventListener('click', (e) => {
            if (e.target.id === 'peared-overlay') this.hidePopup();
        });
        
        // Host button
        document.getElementById('peared-start-host').addEventListener('click', () => this._startHosting());
        
        // Copy buttons
        document.getElementById('peared-copy-code').addEventListener('click', () => {
            const code = document.getElementById('peared-host-code');
            code.select();
            document.execCommand('copy');
            document.getElementById('peared-copy-code').textContent = '‚úì Copied!';
            setTimeout(() => {
                document.getElementById('peared-copy-code').textContent = 'üìã Copy Code';
            }, 2000);
        });
        
        document.getElementById('peared-copy-answer').addEventListener('click', () => {
            const code = document.getElementById('peared-answer-code');
            code.select();
            document.execCommand('copy');
            document.getElementById('peared-copy-answer').textContent = '‚úì Copied!';
            setTimeout(() => {
                document.getElementById('peared-copy-answer').textContent = 'üìã Copy Response';
            }, 2000);
        });
        
        // Connect button (for client)
        document.getElementById('peared-connect').addEventListener('click', () => this._handleJoinCode());
        
        // Accept Player button (for host)
        document.getElementById('peared-accept-player').addEventListener('click', () => this._handleAcceptPlayer());
        
        // Camera buttons
        document.getElementById('peared-start-camera').addEventListener('click', () => this._startCamera());
        document.getElementById('peared-stop-camera').addEventListener('click', () => this._stopCamera());
    }
    
    async _handleAcceptPlayer() {
        const code = document.getElementById('peared-answer-input').value.trim();
        if (!code) {
            this._showStatus('Please paste the player\'s response code', 'warning');
            return;
        }
        
        this._log('info', 'Processing player response...');
        
        try {
            const answerData = this._decompress(code);
            
            if (!answerData.answer) {
                this._showStatus('Invalid response code - not an answer', 'error');
                this._log('error', 'Invalid answer data - missing answer field');
                return;
            }
            
            const success = await this._processAnswer(answerData);
            
            if (success) {
                this._showStatus('Player connecting...', 'success');
                document.getElementById('peared-answer-input').value = '';
                
                // Generate new offer for next player
                await this._refreshHostOffer();
            } else {
                this._showStatus('Failed to accept player - invalid or expired code', 'error');
            }
        } catch (error) {
            this._log('error', 'Error accepting player', error.message);
            this._showStatus('Error: ' + error.message, 'error');
        }
    }
    
    _updateConnectedPlayersList() {
        const container = document.getElementById('peared-connected-players');
        const noPlayersMsg = document.getElementById('peared-no-players');
        
        if (!container) return;
        
        const connectedPeers = Array.from(this.peers.values()).filter(p => p.player);
        
        if (connectedPeers.length === 0) {
            if (noPlayersMsg) noPlayersMsg.style.display = 'block';
        } else {
            if (noPlayersMsg) noPlayersMsg.style.display = 'none';
            
            // Build player list HTML
            let html = '<div class="peared-divider">‚Äî Connected Players ‚Äî</div>';
            connectedPeers.forEach(peer => {
                html += `
                    <div class="peared-pending-item">
                        <span style="color: ${peer.player.color}">‚óè ${peer.player.name}</span>
                        <span style="color: #666; font-size: 11px;">Connected</span>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
    }
    
    async _startHosting() {
        const playerName = document.getElementById('peared-player-name').value || 'Host';
        const isPublic = document.getElementById('peared-public-room')?.checked ?? true;

        this.host(playerName);

        document.getElementById('peared-start-host').style.display = 'none';
        document.getElementById('peared-host-active').style.display = 'block';
        document.getElementById('peared-room-code').textContent = '......';

        // Create Firebase room
        try {
            // Create offer FIRST (before room is visible)
            this._log('info', 'Preparing connection offer...');
            const offerData = await this._createHostOffer();
            const compressed = this._compress(offerData);
            document.getElementById('peared-host-code').value = compressed;

            // NOW create the room with the offer already included
            this.roomCode = await this.firebase.createRoomWithOffer(playerName, isPublic, offerData);
            document.getElementById('peared-room-code').textContent = this.roomCode;
            this._log('success', `Room created: ${this.roomCode}`);

            // Start heartbeat to keep room alive
            this._startHeartbeat();

            // Listen for answers via Firebase
            this.firebase.onAnswer(async (answerData) => {
                this._log('info', 'Received answer via Firebase');
                const success = await this._processAnswer(answerData);
                if (success) {
                    this._showStatus('Player connected!', 'success');
                    // Generate new offer for next player
                    await this._refreshHostOffer();
                    // Update player count
                    this.firebase.updatePlayerCount(this.getPlayers().length);
                }
            });

        } catch (error) {
            this._log('error', 'Failed to create room', error.message);
            this._showStatus('Failed to create room: ' + error.message, 'error');
            // Fallback to manual mode
            document.getElementById('peared-room-code').textContent = 'OFFLINE';
        }
    }

    async _refreshHostOffer() {
        const offerData = await this._createHostOffer();
        const compressed = this._compress(offerData);

        // Update manual code field
        document.getElementById('peared-host-code').value = compressed;

        // Publish to Firebase
        if (this.firebase.roomRef) {
            await this.firebase.setOffer(offerData);
        }
    }
    
    async _handleJoinCode() {
        const code = document.getElementById('peared-join-code').value.trim();
        if (!code) {
            this._showStatus('Please paste the host\'s code', 'warning');
            return;
        }
        
        this._log('info', 'Processing host code...');
        
        try {
            const offerData = this._decompress(code);
            this._log('info', `Host found: "${offerData.hostName}"`);
            
            this._showStatus('Connecting to ' + offerData.hostName + '...', 'info');
            
            const answerData = await this._createClientAnswer(offerData);
            const compressed = this._compress(answerData);
            
            document.getElementById('peared-join-answer').style.display = 'block';
            document.getElementById('peared-answer-code').value = compressed;
            
            this._showStatus('‚ö†Ô∏è Copy the response below and send it to the host!', 'warning');
            this._log('success', 'Answer generated - waiting for host to accept');
            
        } catch (error) {
            this._log('error', 'Error processing host code', error.message);
            this._showStatus('Invalid code: ' + error.message, 'error');
        }
    }
    
    _showStatus(message, type) {
        const status = document.getElementById('peared-status');
        status.textContent = message;
        status.className = `peared-status ${type}`;
        status.style.display = 'block';
    }
    
    _updateState() {
        this.options.onStateChange(this.state, this.isHost);
    }
    
    // Camera handling
    async _startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
            const video = document.getElementById('peared-video');
            video.srcObject = stream;
            await video.play();
            
            this._cameraStream = stream;
            this._scanning = true;
            
            document.getElementById('peared-start-camera').style.display = 'none';
            document.getElementById('peared-stop-camera').style.display = 'block';
            
            this._scanQR();
        } catch (error) {
            this._showStatus('Camera error: ' + error.message, 'error');
        }
    }
    
    _stopCamera() {
        this._scanning = false;
        if (this._cameraStream) {
            this._cameraStream.getTracks().forEach(t => t.stop());
            this._cameraStream = null;
        }
        document.getElementById('peared-video').srcObject = null;
        document.getElementById('peared-start-camera').style.display = 'block';
        document.getElementById('peared-stop-camera').style.display = 'none';
    }
    
    _scanQR() {
        if (!this._scanning) return;
        
        const video = document.getElementById('peared-video');
        const canvas = document.getElementById('peared-canvas');
        
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const code = jsQR(imageData.data, imageData.width, imageData.height);
            
            if (code) {
                this._stopCamera();
                document.getElementById('peared-join-code').value = code.data;
                this._handleJoinCode();
                return;
            }
        }
        
        requestAnimationFrame(() => this._scanQR());
    }
    
    // ===== PRIVATE: UTILITIES =====
    
    _generateId() {
        return Math.random().toString(36).substring(2, 12);
    }
    
    _generateColor() {
        const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e91e63', '#00bcd4'];
        return colors[Math.floor(Math.random() * colors.length)];
    }
    
    _compress(data) {
        const json = JSON.stringify(data);
        const compressed = LZString.compressToEncodedURIComponent(json);
        return compressed.length < json.length ? compressed : json;
    }
    
    _decompress(data) {
        try {
            // Try as JSON first
            return JSON.parse(data);
        } catch {
            // Try LZ decompression
            const decompressed = LZString.decompressFromEncodedURIComponent(data);
            return JSON.parse(decompressed);
        }
    }
}

/*=============================================
  BLOCK WORLD GAME
  =============================================
  A simple multiplayer game where players are
  colored cubes that can move around.
=============================================*/

class BlockWorld {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        
        this.players = new Map(); // playerId -> { x, y, name, color }
        this.localPlayerId = null;
        
        this.keys = {};
        this.moveSpeed = 5;
        this.playerSize = 40;
        
        this._resize();
        window.addEventListener('resize', () => this._resize());
        
        // Input handling
        window.addEventListener('keydown', (e) => {
            this.keys[e.key.toLowerCase()] = true;
            this.keys[e.code] = true;
        });
        window.addEventListener('keyup', (e) => {
            this.keys[e.key.toLowerCase()] = false;
            this.keys[e.code] = false;
        });
        
        // Start game loop
        this._lastUpdate = Date.now();
        this._gameLoop();
    }
    
    setLocalPlayer(player) {
        console.log('[Game] setLocalPlayer:', player.id, player.name);
        this.localPlayerId = player.id;
        this.players.set(player.id, {
            id: player.id,
            x: this.canvas.width / 2,
            y: this.canvas.height / 2,
            name: player.name,
            color: player.color,
            isHost: player.isHost
        });
    }
    
    addPlayer(player) {
        console.log('[Game] addPlayer called with:', player.id, player.name);
        if (!this.players.has(player.id)) {
            this.players.set(player.id, {
                id: player.id,  // Store ID for debugging
                x: Math.random() * (this.canvas.width - 100) + 50,
                y: Math.random() * (this.canvas.height - 100) + 50,
                name: player.name,
                color: player.color,
                isHost: player.isHost
            });
            console.log('[Game] Player added. Total players:', this.players.size);
            console.log('[Game] Player IDs:', [...this.players.keys()]);
        } else {
            console.log('[Game] Player already exists:', player.id);
        }
    }
    
    removePlayer(playerId) {
        this.players.delete(playerId);
    }
    
    updatePlayer(playerId, data) {
        console.log('[Game] updatePlayer called with ID:', playerId, 'localPlayerId:', this.localPlayerId);
        const player = this.players.get(playerId);
        if (player) {
            console.log('[Game] Found player to update:', player.name);
            player.x = data.x;
            player.y = data.y;
            if (data.name) player.name = data.name;
        } else {
            console.log('[Game] Player NOT FOUND! Available IDs:', [...this.players.keys()]);
        }
    }
    
    getLocalPlayerState() {
        const local = this.players.get(this.localPlayerId);
        if (local) {
            return { x: local.x, y: local.y, name: local.name };
        }
        return null;
    }
    
    _resize() {
        this.canvas.width = this.canvas.parentElement.clientWidth;
        this.canvas.height = this.canvas.parentElement.clientHeight;
    }
    
    _gameLoop() {
        const now = Date.now();
        const dt = (now - this._lastUpdate) / 1000;
        this._lastUpdate = now;
        
        this._update(dt);
        this._render();
        
        requestAnimationFrame(() => this._gameLoop());
    }
    
    _update(dt) {
        const local = this.players.get(this.localPlayerId);
        if (!local) return;
        
        let moved = false;
        
        // Movement
        if (this.keys['arrowleft'] || this.keys['a'] || this.keys['ArrowLeft']) {
            local.x -= this.moveSpeed;
            moved = true;
        }
        if (this.keys['arrowright'] || this.keys['d'] || this.keys['ArrowRight']) {
            local.x += this.moveSpeed;
            moved = true;
        }
        if (this.keys['arrowup'] || this.keys['w'] || this.keys['ArrowUp']) {
            local.y -= this.moveSpeed;
            moved = true;
        }
        if (this.keys['arrowdown'] || this.keys['s'] || this.keys['ArrowDown']) {
            local.y += this.moveSpeed;
            moved = true;
        }
        
        // Bounds
        local.x = Math.max(this.playerSize/2, Math.min(this.canvas.width - this.playerSize/2, local.x));
        local.y = Math.max(this.playerSize/2, Math.min(this.canvas.height - this.playerSize/2, local.y));
        
        // Emit movement if changed
        if (moved && this._onMove) {
            this._onMove({ x: local.x, y: local.y });
        }
    }
    
    onMove(callback) {
        this._onMove = callback;
    }
    
    _render() {
        const ctx = this.ctx;
        
        // Clear with grid background
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Grid
        ctx.strokeStyle = '#2a2a4e';
        ctx.lineWidth = 1;
        const gridSize = 50;
        
        for (let x = 0; x < this.canvas.width; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, this.canvas.height);
            ctx.stroke();
        }
        for (let y = 0; y < this.canvas.height; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(this.canvas.width, y);
            ctx.stroke();
        }
        
        // Draw players
        this.players.forEach((player, id) => {
            const isLocal = id === this.localPlayerId;
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(
                player.x - this.playerSize/2 + 4,
                player.y - this.playerSize/2 + 4,
                this.playerSize,
                this.playerSize
            );
            
            // Player cube
            ctx.fillStyle = player.color;
            ctx.fillRect(
                player.x - this.playerSize/2,
                player.y - this.playerSize/2,
                this.playerSize,
                this.playerSize
            );
            
            // Highlight for local player
            if (isLocal) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.strokeRect(
                    player.x - this.playerSize/2,
                    player.y - this.playerSize/2,
                    this.playerSize,
                    this.playerSize
                );
            }
            
            // Name tag
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(
                player.name + (player.isHost ? ' üëë' : ''),
                player.x,
                player.y - this.playerSize/2 - 10
            );
        });
    }
}

/*=============================================
  MAIN APPLICATION
  =============================================*/

// Initialize game
const game = new BlockWorld('game-canvas');

// Initialize Peared networking
const peared = new Peared({
    onPlayerJoin: (player) => {
        console.log('Player joined:', player);
        game.addPlayer(player);
        updatePlayerList();
    },

    onPlayerLeave: (player) => {
        console.log('Player left:', player);
        game.removePlayer(player.id);
        updatePlayerList();
    },

    onMessage: (from, type, data) => {
        console.log('[Peared] onMessage - from:', from, 'type:', type);
        if (type === 'move') {
            game.updatePlayer(from, data);
        }
    },

    onStateChange: (state, isHost) => {
        updateConnectionUI(state, isHost);
    },

    // State sync: host provides current game state
    getState: () => {
        const state = {};
        game.players.forEach((player, id) => {
            state[id] = { x: player.x, y: player.y };
        });
        console.log('[Game] getState called, returning:', state);
        return state;
    },

    // State sync: clients receive and apply game state
    onStateSync: (state) => {
        console.log('[Game] onStateSync received:', state);
        Object.entries(state).forEach(([id, pos]) => {
            game.updatePlayer(id, pos);
        });
    }
});

// Send position updates
let lastSentPosition = { x: 0, y: 0 };
game.onMove((position) => {
    // Throttle updates
    if (Math.abs(position.x - lastSentPosition.x) > 2 || 
        Math.abs(position.y - lastSentPosition.y) > 2) {
        peared.send('move', position);
        lastSentPosition = { ...position };
    }
});

// UI Updates
function updatePlayerList() {
    const container = document.getElementById('players');
    const players = peared.getPlayers();
    
    container.innerHTML = players.map(p => `
        <div class="player-item">
            <div class="player-color" style="background: ${p.color}"></div>
            <span class="player-name">${p.name}</span>
            ${p.isHost ? '<span class="player-host">HOST</span>' : ''}
        </div>
    `).join('');
}

function updateConnectionUI(state, isHost) {
    const btn = document.getElementById('connect-btn');
    const status = document.getElementById('connection-status');
    
    if (state === 'hosting') {
        btn.textContent = 'üéÆ Hosting...';
        btn.className = 'hosting';
        status.textContent = `Hosting as ${peared.localPlayer?.name}`;
    } else if (state === 'connected') {
        btn.textContent = '‚úì Connected';
        btn.className = 'connected';
        status.textContent = `Connected to game`;
        peared.hidePopup();
    } else {
        btn.textContent = 'üéÆ Host or Join';
        btn.className = '';
        status.textContent = 'Not connected';
    }
    
    updatePlayerList();
}

// Connect button
document.getElementById('connect-btn').addEventListener('click', () => {
    peared.showPopup();
});

// Initialize local player visually when hosting starts
const originalHost = peared.host.bind(peared);
peared.host = function(name) {
    const player = originalHost(name);
    game.setLocalPlayer(player);
    return player;
};

// Handle when client connects (manual method)
const originalCreateClientAnswer = peared._createClientAnswer.bind(peared);
peared._createClientAnswer = async function(offerData) {
    const answer = await originalCreateClientAnswer(offerData);
    game.setLocalPlayer(peared.localPlayer);
    return answer;
};

// Handle when client connects via Firebase
const originalCreateClientAnswerFromOffer = peared._createClientAnswerFromOffer.bind(peared);
peared._createClientAnswerFromOffer = async function(offerData) {
    const answer = await originalCreateClientAnswerFromOffer(offerData);
    game.setLocalPlayer(peared.localPlayer);
    return answer;
};
</script>
</body>
</html>
